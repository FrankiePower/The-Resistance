{"noir_version":"1.0.0-beta.18+99bb8b5cf33d7669adbdef096b12d80f30b4c0c9","hash":"10649561355880138404","abi":{"parameters":[{"name":"bases","type":{"kind":"array","length":10,"type":{"kind":"integer","sign":"unsigned","width":32}},"visibility":"private"},{"name":"bases_hash","type":{"kind":"field"},"visibility":"public"},{"name":"action_type","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"target_id","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"neighbors","type":{"kind":"array","length":20,"type":{"kind":"integer","sign":"unsigned","width":32}},"visibility":"public"},{"name":"neighbor_count","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"}],"return_type":{"abi_type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},"error_types":{"263243472447917552":{"error_kind":"string","string":"Invalid action type"},"552702492994298065":{"error_kind":"string","string":"Base commitment mismatch - cheating detected!"},"13529555878805714440":{"error_kind":"string","string":"Target star ID out of range"},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"}}},"bytecode":"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","debug_symbols":"pZzdrhxFtoTfZV/7otZPrlw5r3I0QgbMyJJlkIGRjhDvPl1d+UWZi23NbK4yYHdHVa2u6IiuDPjj5ccP3//+r+8+fv7p519f/vF/f7x8/+Xjp08f//Xdp59/eP/bx58/P/7tH3++e+Efv/vty4cPj3/18tXfH+/65f2XD59/e/nH598/fXr38u/3n35/vujXX95/fq6/vf/y+Ovx7uXD5x8f64Pwp4+fPpzoz3f3u4/X32qda7/bepoIhv2FwV5nWNGbYGX9vfeP8dr7v3kFa3IFK47XGPJ1hhi+CWLN+/3rL+8fr7/f3WITuHu9xlDfuAZLGMzqTQy+uAssjvUaQ3/jc/Dic4i3vN+OQ9dw5KvXYN/4KLNtbIrs4aKwt1zEqDd9lPPQR9n56kXEN+YwRzKHOeNVivybH8V/SfD6GL5F0C1RHvMtBP/t3dB/+2745mfRtyrW8epn8a1vl3Urc83jDd9PbpOvF7fuNzGs+/vla23/L+dgYrA3XYVbiiGOv3sOYW9hiNA5RL5pDpXcUl5v+zR76LPor9X9PzCsFsN6y1XE/VmEh7+JoZYY2t7EMPpvMsR9FWFvcf44Dj7NOPxN5zAOskOMN93VMfJmqDd9mmNpDmO9aQ5ZKCtyzrcwVOh+qPHXSf7z8U/vf/j45S/J9SXijCrvXiL3OvZae5177b2ua81jr7ZX3+vJ9ziHzL2O8xvjsdb5dfFY5157r+v8Enj3Mo692l4ffP64K0bsNfd68j1McdReT77HJzd6r+ta69jryfe4w8v3GnvNvY691l5Pvsd5V+91Xes89vrgi8f1TN9r7DXP2/+xjr3WXudee6/r/HDfvfSx183Xm683X+deN19vvt58vfl6XevafMv2uvnW5lubb429br61+dbmW5vv4fuAzWiHAzbnIxAABqAAk7c3AGaD2QwAswUAZoPZYLYJgNlgdpgdZncAzJ4AmB1mh9kbAHPAHDAHzKeCLgDzqaELwBwwB8ynjp4gYU6YE+aEORMA8ymnC8CcMCfMp6QuAPOAecA8YB4DAPOprAvAPGAumMsAMBfMBXPBXAWA+RTZBWCeMKMzQ2g2YUZqhtYMsRlqswkzerOGGcUZkjM0Zw0zqjNkZ+jOEJ41zEjPFsyIz1CfIT9bMCNAQ4GGBA0N+rGZHQ36sZkdDToadDToR/H2CWgAzGjQDWY06AYzGnQ06GjQDWY06GjQ0aCjQXeY0aA7zGjQ0aCjQXeY0aCjQUeDjgY9YEaDHjCjQUeDjgY9YEaDjgYdDToa9IQZDXrCjAYdDToa9AEzGnQ06GjQ0aAPmNGgD5jRoKNBR4NeMKNBR4OOBh0NesGMBr1gRoOOBh0N+oQZDToadDToaNAnzGjQJ8xo0NGgo0FvmNGgo0FHg44GvWFGg/7UYJ3AAA4IQAIG4GSeJ5iABqwLxFODfQID+BUF4tTgBRIwAPucAw0GGgw0GLbVHWgwzPlTABIwAMWLJwBmNBhoMNBgoMFAg+EwO8zOOTvn7M2L95wDDQYaDDQY+GCgwcAHI2AOmINzRoORTCOZBhoMNBj4YCTnjA9GMo2EOWFGg4EGYzCNwTTQYOCDMTjnwTkPpjGYRsGMBgMNBhqMYhrFNPDBKJiLcy7OeTKNyTTQYKDBQIOBBmMyDTQYxM6YMDfn3JxzM41mGmgw0GCgwUCDgQYDDcaCecG8OOfFOS+msZgGPhj4YOCDgQ8mPpj4YB7OnwKQgAEoXjwBzZ9gxgeTLJr4YJJFEw0mGkwrwAQ0L97TSDSYaDDJoumcM1k0fQDq+mrKpwafoAFrgzgABvDryyqfGnyCBAzAydwnmIAHcx4nWBvk/pGTpwYv4IAAMA00mMk0kmkk00imgQYTDSY+mPhgDqaBDyYaTDSYg09w8AkW90Zxb6DBRIOJDyY+mPhg4oOJBhMN5uScJ+c8uTcm9wYaTDSY+GCSRRMfTLJoosFEg9mcMz6YzTSaaaDBRINJFk1+BSZZNPkdmGgw0WAuzpksmotpLKaBBhMNDn4PjsMAexrjCEDypwEowAQ0L97TGGhwoMGBDw58cFjy4gGAGQ0OfHDgg8P3NIYbAGY0OPDBgQ8OL148ATCTRQc+OPDBEUyDLDoC5oAZHxz44AimEUyDLDrIogMfHPjgIIsOsuhAgwMNDnxw4INjMI3BNNDgQIMDHxz44CCLDn4PDjQ40ODABwc+OIppFNOonb5GDUABJqAB+7tuPDV4PtZ5avAJHBCAk7lPMAB1faGNU4MX2I9zxtzPc0YfAAMwDTQ48MGBD45mGs000OBAgwMfHPjgWExjMQ00ONDgwAcHPjgW98ba90ahwUKDhQ8WPlhH8uIBKP40AQ3Y51xk0SKLFhosNFj4YOGDRRYtsmihwUKDhQ8WPlhk0SKLFhosNFhk0SKLFlm0yKKFBgsNFlm0yKJFFi2yaKHBQoNFFi2yaJFFiyxaaLDQYOGDhQ8WWbTIooUGCw0WPlj4YJFFiyxaaLDQYOGDhQ8WWbTIooUGCw0WPlj4YJFFiyxaZNEiixY+WPhgkUWLLFpk0SKLFj5Y+GCRRYssWmTRIosWPlj4YJFFiyxaaLDQYOGDhQ8WWbTIooUGCw0WPlj4YJFFiyxaaLDQYOGDhQ9Osugki85j/9KcRwASMAAFmID9S3Me+5fmtANggJO5TxCAvL7Q5qnBCxQPpiegATy7RoMTDU58cOKDkyw6yaITDU40OPHBiQ/OYBrBNNDgRIMTH5z44IzixRMAMxqc+ODEB2fue2NmAGBGgxMfnPjgJItOsuhEgxMNTnxw4oOTLDrJohMNTjQ48cGJD06y6CSLTjQ40eAki87STgHTIItONDjR4CSLTrLoJItOsujUFoT2IO5NCM6ZLDrJohMNTjQ48cGJD06y6CSLTjQ4W/sbnDM+OMmikyw60eBEgxMfnPjgJItOsuhc2jrZzI0PNj7YZNEmizZZtMmijQ82Pthk0SaLNlm0yaKNDzY+2GTRJos2WbTJoo0PNj7YZNEmizYabDTY+GDjg00WbbJoo8FGg40PNj7YZNEmizYabDTY+GDjg00WbbJo5/6l2WkABwQgAQOwn6p1TkAD9nddj/1UrYcB/PpC61ODF9hP1XoMQAEmgGmgwcYHGx9ssmiTRRsNdml3jWngg83eRBfTQIONBhsfbHywJ/fG5N6Y2riDGR9sfLC1GdjcG2iw0WDjg60dQbJok0Vbm4JosPHBxgebLNpk0UaDjQYbH2x8sMmiTRZdaHChwUUWXWTRRRZdZNGFBhcaXGTRRRZdpq1M9jLR4EKDiyy6yKKLLLrIogsNLjS48MGFDy6y6CKLLjS40ODCBxc+uMiiiyy60OBCgwsfXPjgIosusuhCgwsNLnxw4YOLLLrIoossusiiCx9c+OAiiy6y6CKLLrLowgcXPrjIoossusiiiyy68MGFDy6y6CKLLjS40ODCBxc+uMiiiyy60OBCgwsfXPjgIosusuhCgwsNLnxw4YOLLLrIomvuX5pr7l+aqw+AARwQgP1UbfUAFGACTuY+wdrg1OD5hbZODV5gP1VbKwAJGACmoR36e4v+3qNn6/G4d+mR4dncE0qhIVR6xxTSZr126w+7iwAmpCqAduwP0zFMx8AYH0h9AB6VPhA7qIc27g/t3B/auj9c16HN+4OU+kA6husYruvQDv4RmlVoVtrEP7SLf4SuI3QdoVmFZhU6RugY2sw/tJt/pGaVmpU29I/UMVLXkbqO1KxSsxo6hvb1D23sH9rZP4ZmNTSroWMMHWPoOoauozSr0qy0xX9oj//QJv+hXf6jNCvt8x+lY5SOMXUdU9cxNaupWWm7/9B+/6EN/0M7/oe2/A/t+R+tY7SO0bqO1nW0ZtWalbb+j767LLqO1nVo+/9YmtXSMZaOsXQd6gAcS7NamtW6CzN3Y0aVmUOdGdVx7FBrRjo36dywXLs7OUbwNSP52te1HB0D4zXDec2Iv2bkX7vKOfVEU6iFFsgPIRPaD/Ts6uhcKIWG0N7AsKunc6G9hWHPps6FYj/Ys2dXZyMXCiHNSjq30KxCswrNKjQr6fxu7dy1nbu3Y6lZqblj0rlJ55aqMqU+cx7XmvG81u4Cz93guSs8d4fnLvHcLR6Tzk06t9J1lK6jdF+V7ivp/G7z3HUeK12HCj1WmpV0btK5TV2HWj02NaupWUnnd7PHpq5j6jpas2rNSjo36fwu+NwNH2vNqjUr6dykc1u6jqXrWJrV0qyk87vrc5d97raPLc2KTG0unbt07vJzl5/7oRIbydpU+zH1fkzFH1Pzx5x4ber+mEvnLp27/Nzl507INidlmypA5ncP7y7ifdXEY1Z+d/Fcx3AdQ37u8nMncJu7ZqVKnvpApkKQufxclSBz9fJcOnfp3OXn6gWZp2aVmpV0rm6Qufzc5eeuip6nZiWdu3SuipCpI2Q+NKuhWY39Q9uuntCFSmgKtRDfu1dZaD6RCblQCO2tFLsaQxfamyn27AxttB8xmtOPNacha8/e0EaalXSu6pCpO2Q+NaupWUnnLp27/Nzl596aVWtW0rlaRKYakalHZCoSmZpE5tK5S+cuP3f5uS/dV0v3lXTu0rnLz11+Hsrtodwe0nlI5yE/D/l5KLeHcrvKRaZ2kYX8POTnodweyu2qGJk6RhbK7aHcHsrtodyuopGpaWSh3B7K7aHcHsrtqhuZ+kYWyu1xN2+V20O5Pb4q3+oY8vOQn4dyeyi3q3pk6h5ZyM9Dfh7K7aHcrgKSqYFkIT8P+Xkot4dyu2pIph6Shfw85Oeh3B7K7SojmdpIFvLzkJ+Hcnsot6uSZOokWcjPQ34eyu2h3K5ikqmZZCE/D/l5KLeHcrvqSaZ+koX8POTnodweyu0qKZlaShby85Cfh3J7KLerqmTqKlnIz0N+HsrtodwelAYtaA1aUBu0oDdoV2npQlNoP+S0oDtoV3HpQia0N3Xs6i5daG/r2LO9tNF+2GnP/tJGLcT3ripMpg6Tpfw85eep3J7K7SoymZpMlvLzlJ8nD68teXptqjOZ+kyW8vOUnyePsC15hm0pnad0nvLzlJ8nD7IteZJtKZ2ndJ7y85Sfp3J7KrfnXba/2/Z33f6rvr1mdTfupXP1nCzl5yk/T+X2VG5X2cnUdrJUbk/l9lRuT+V2VZ5MnSdL5fZUbk/l9lRuV/HJ1HyyVG5P5fZUbk/ldtWfTP0nS/l5ys9TuT2V21WCMrWgLOXnKT9P5fZUblcVytSFspSfp/w8ldtTuV2FKFMjylJ+nvLzVG5P5XbVoky9KEv5ecrPU7k9ldtVjjK1o2zIz4f8fCi3D+V2VaRMHSkb8vMhPx/K7UO5XUUpU1PKhvx8yM+HcvtQblddytSXsiE/H/Lzodw+lNtVmjK1pmzIz4f8fCi3D+X2QX3RBv1Fu8pTFwqhFBpC+3GrXQ2qC7UQ37tXiaqfyIT2BpM9e1R5/keC/37/5eP77z99+PX6fzj89PvnH776Xzr89v+/8Bf+pw+/fPn5hw8//v7lw/kf0T3/9uc///wP","file_map":{"19":{"source":"// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Decompose the input 'bn254 scalar' into two 128 bits limbs.\n// It is called 'unsafe' because it does not assert the limbs are 128 bits\n// Assuming the limbs are 128 bits:\n// Assert the decomposition does not overflow the field size.\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    // Check that the decomposition does not overflow the field size\n    let (a, b) = if xhi == crate::field::bn254::PHI {\n        (xlo, crate::field::bn254::PLO)\n    } else {\n        (xhi, crate::field::bn254::PHI)\n    };\n    crate::field::bn254::assert_lt(a, b);\n\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"51":{"source":"// THE RESISTANCE: 3D Galactic War Circuit\n// Proves the result of weapon/scanner actions against secret bases using star IDs.\n//\n// Game Setup:\n// - 200 stars total (IDs: 0-199)\n// - 10 arms of 20 stars each (Arm 0 = stars 0-19, Arm 1 = stars 20-39, etc.)\n// - Each player hides 10 bases among the 200 stars\n//\n// Actions:\n// - Solar Scan (0): Precision strike on a single star\n// - Deep Radar (1): Scan a region, count bases within neighbor radius\n// - Arm Strike (2): Devastate an entire arm, destroy all bases in that arm\n\nuse poseidon::poseidon2::Poseidon2;\n\n// Maximum neighbors for Deep Radar scan (adjustable based on radius)\nglobal MAX_NEIGHBORS: u32 = 20;\n\n// Stars per arm for Arm Strike calculation\nglobal STARS_PER_ARM: u32 = 20;\n\n// Helper: Convert u32 array to Field array for hashing\nfn bases_to_fields(bases: [u32; 10]) -> [Field; 10] {\n    let mut fields: [Field; 10] = [0; 10];\n    for i in 0..10 {\n        fields[i] = bases[i] as Field;\n    }\n    fields\n}\n\nfn main(\n    // PRIVATE - your 10 secret base star IDs (0-199)\n    bases: [u32; 10],\n\n    // PUBLIC - commitment hash of your bases\n    bases_hash: pub Field,\n\n    // PUBLIC - action type\n    // 0 = Solar Scan (single star precision strike)\n    // 1 = Deep Radar (count bases in neighbor radius)\n    // 2 = Arm Strike (destroy entire spiral arm)\n    action_type: pub u32,\n\n    // PUBLIC - target star ID (0-199)\n    target_id: pub u32,\n\n    // PUBLIC - neighbor star IDs for Deep Radar (unused for other actions)\n    // These are precomputed by the frontend based on 3D positions\n    neighbors: pub [u32; MAX_NEIGHBORS],\n    neighbor_count: pub u32,\n) -> pub u32 {\n\n    // ===========================================\n    // 1. VERIFY BASE COMMITMENT\n    // ===========================================\n    // Convert bases to Field array for hashing\n    let bases_fields = bases_to_fields(bases);\n    let computed_hash = Poseidon2::hash(bases_fields, 10);\n    assert(computed_hash == bases_hash, \"Base commitment mismatch - cheating detected!\");\n\n    // ===========================================\n    // 2. VALIDATE INPUTS\n    // ===========================================\n    assert(\n        (action_type == 0) | (action_type == 1) | (action_type == 2),\n        \"Invalid action type\"\n    );\n\n    // Validate target_id is in valid range (0-199)\n    assert(target_id < 200, \"Target star ID out of range\");\n\n    // ===========================================\n    // 3. EXECUTE ACTION & COUNT HITS\n    // ===========================================\n    let mut result: u32 = 0;\n\n    // Calculate target's arm index for Arm Strike (integer division)\n    let target_arm = target_id / STARS_PER_ARM;\n\n    for i in 0..10 {\n        let base_id = bases[i];\n        let mut hit: u32 = 0;\n\n        // [ACTION 0] SOLAR SCAN: Exact star match\n        if action_type == 0 {\n            if base_id == target_id {\n                hit = 1;\n            }\n        }\n\n        // [ACTION 1] DEEP RADAR: Check if base is in neighbor list\n        if action_type == 1 {\n            // Loop through the neighbor list to check membership\n            for j in 0..MAX_NEIGHBORS {\n                // Only check up to neighbor_count valid entries\n                if j < neighbor_count {\n                    if base_id == neighbors[j] {\n                        hit = 1;\n                    }\n                }\n            }\n        }\n\n        // [ACTION 2] ARM STRIKE: Same arm = hit (integer division)\n        if action_type == 2 {\n            let base_arm = base_id / STARS_PER_ARM;\n            if base_arm == target_arm {\n                hit = 1;\n            }\n        }\n\n        result = result + hit;\n    }\n\n    result\n}\n\n// ===========================================\n// HELPER: Compute hash for tests\n// ===========================================\nfn compute_test_hash(bases: [u32; 10]) -> Field {\n    let bases_fields = bases_to_fields(bases);\n    Poseidon2::hash(bases_fields, 10)\n}\n\n// ===========================================\n// TESTS\n// ===========================================\n\n#[test]\nfn test_solar_scan_hit() {\n    // Setup: Base at star 42\n    let mut bases: [u32; 10] = [0; 10];\n    bases[0] = 42;\n\n    let bases_hash = compute_test_hash(bases);\n    let neighbors: [u32; MAX_NEIGHBORS] = [0; MAX_NEIGHBORS];\n\n    // Scan star 42 - should hit\n    let result = main(bases, bases_hash, 0, 42, neighbors, 0);\n    assert(result == 1);\n}\n\n#[test]\nfn test_solar_scan_miss() {\n    // Setup: Base at star 42\n    let mut bases: [u32; 10] = [0; 10];\n    bases[0] = 42;\n\n    let bases_hash = compute_test_hash(bases);\n    let neighbors: [u32; MAX_NEIGHBORS] = [0; MAX_NEIGHBORS];\n\n    // Scan star 43 - should miss\n    let result = main(bases, bases_hash, 0, 43, neighbors, 0);\n    assert(result == 0);\n}\n\n#[test]\nfn test_deep_radar_finds_multiple() {\n    // Setup: Bases at stars 10, 15, 42, 100\n    let mut bases: [u32; 10] = [0; 10];\n    bases[0] = 10;\n    bases[1] = 15;\n    bases[2] = 42;\n    bases[3] = 100;\n\n    let bases_hash = compute_test_hash(bases);\n\n    // Neighbors of star 12 include stars 10, 11, 13, 14, 15 (within radius)\n    let mut neighbors: [u32; MAX_NEIGHBORS] = [0; MAX_NEIGHBORS];\n    neighbors[0] = 10;\n    neighbors[1] = 11;\n    neighbors[2] = 13;\n    neighbors[3] = 14;\n    neighbors[4] = 15;\n    let neighbor_count: u32 = 5;\n\n    // Radar scan should find 2 bases (10 and 15)\n    let result = main(bases, bases_hash, 1, 12, neighbors, neighbor_count);\n    assert(result == 2);\n}\n\n#[test]\nfn test_deep_radar_finds_none() {\n    // Setup: Bases at stars 100, 150\n    let mut bases: [u32; 10] = [0; 10];\n    bases[0] = 100;\n    bases[1] = 150;\n\n    let bases_hash = compute_test_hash(bases);\n\n    // Neighbors of star 12 (stars 10-15) - no bases here\n    let mut neighbors: [u32; MAX_NEIGHBORS] = [0; MAX_NEIGHBORS];\n    neighbors[0] = 10;\n    neighbors[1] = 11;\n    neighbors[2] = 13;\n    neighbors[3] = 14;\n    neighbors[4] = 15;\n    let neighbor_count: u32 = 5;\n\n    // Radar scan should find 0 bases\n    let result = main(bases, bases_hash, 1, 12, neighbors, neighbor_count);\n    assert(result == 0);\n}\n\n#[test]\nfn test_arm_strike_destroys_multiple() {\n    // Setup:\n    // - Arm 3 = stars 60-79\n    // - Bases at stars 65, 72, 78 (all in Arm 3) + star 100 (Arm 5)\n    let mut bases: [u32; 10] = [0; 10];\n    bases[0] = 65;  // Arm 3 (65/20 = 3)\n    bases[1] = 72;  // Arm 3 (72/20 = 3)\n    bases[2] = 78;  // Arm 3 (78/20 = 3)\n    bases[3] = 100; // Arm 5 (100/20 = 5)\n\n    let bases_hash = compute_test_hash(bases);\n    let neighbors: [u32; MAX_NEIGHBORS] = [0; MAX_NEIGHBORS];\n\n    // Strike star 70 (Arm 3) - should destroy 3 bases\n    let result = main(bases, bases_hash, 2, 70, neighbors, 0);\n    assert(result == 3);\n}\n\n#[test]\nfn test_arm_strike_misses() {\n    // Setup: Bases at stars 10, 25 (Arms 0 and 1)\n    let mut bases: [u32; 10] = [0; 10];\n    bases[0] = 10;  // Arm 0 (10/20 = 0)\n    bases[1] = 25;  // Arm 1 (25/20 = 1)\n\n    let bases_hash = compute_test_hash(bases);\n    let neighbors: [u32; MAX_NEIGHBORS] = [0; MAX_NEIGHBORS];\n\n    // Strike star 150 (Arm 7) - should destroy 0 bases\n    let result = main(bases, bases_hash, 2, 150, neighbors, 0);\n    assert(result == 0);\n}\n\n#[test]\nfn test_arm_boundaries() {\n    // Verify arm calculation: star 19 = Arm 0, star 20 = Arm 1\n    // Place bases in different arms so we can test boundary correctly\n    let mut bases: [u32; 10] = [0; 10];\n    bases[0] = 19;   // Arm 0 (19/20 = 0)\n    bases[1] = 20;   // Arm 1 (20/20 = 1)\n    bases[2] = 60;   // Arm 3\n    bases[3] = 80;   // Arm 4\n    bases[4] = 100;  // Arm 5\n    bases[5] = 120;  // Arm 6\n    bases[6] = 140;  // Arm 7\n    bases[7] = 160;  // Arm 8\n    bases[8] = 180;  // Arm 9\n    bases[9] = 199;  // Arm 9\n\n    let bases_hash = compute_test_hash(bases);\n    let neighbors: [u32; MAX_NEIGHBORS] = [0; MAX_NEIGHBORS];\n\n    // Strike Arm 0 (target star 5) - should only hit star 19\n    let result = main(bases, bases_hash, 2, 5, neighbors, 0);\n    assert(result == 1);\n\n    // Strike Arm 1 (target star 25) - should only hit star 20\n    let result2 = main(bases, bases_hash, 2, 25, neighbors, 0);\n    assert(result2 == 1);\n}\n\n#[test]\nfn test_all_bases_in_one_arm() {\n    // Edge case: All 10 bases in same arm (Arm 2 = stars 40-59)\n    let mut bases: [u32; 10] = [0; 10];\n    bases[0] = 40;\n    bases[1] = 41;\n    bases[2] = 42;\n    bases[3] = 43;\n    bases[4] = 44;\n    bases[5] = 45;\n    bases[6] = 46;\n    bases[7] = 47;\n    bases[8] = 48;\n    bases[9] = 49;\n\n    let bases_hash = compute_test_hash(bases);\n    let neighbors: [u32; MAX_NEIGHBORS] = [0; MAX_NEIGHBORS];\n\n    // Strike Arm 2 (stars 40-59) - should destroy all 10\n    let result = main(bases, bases_hash, 2, 45, neighbors, 0);\n    assert(result == 10);\n}\n","path":"/Users/user/SuperFranky/The-Resistance/circuits/src/main.nr"},"59":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/Users/user/nargo/github.com/noir-lang/poseidon/v0.2.0/src/poseidon2.nr"}},"expression_width":{"Bounded":{"width":4}}}